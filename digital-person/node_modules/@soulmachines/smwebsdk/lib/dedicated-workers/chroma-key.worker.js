/// <reference types="dom-webcodecs" />
'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.render_rgb = exports.initWebGL_rgb_with_canvas = exports.initWebGL_rgb = exports.offscreenCanvas = exports.updateChromaKeyOptions = void 0;
var tslib_1 = require("tslib");
var keyColor = {
    r: 4 / 255,
    g: 244 / 255,
    b: 4 / 255,
};
var similarity = 0.4;
var smoothness = 0.08;
var spill = 0.1;
function updateChromaKeyOptions(options) {
    keyColor = options.keyColor || keyColor;
    similarity = options.similarity || similarity;
    smoothness = options.smoothness || smoothness;
    spill = options.spill || spill;
}
exports.updateChromaKeyOptions = updateChromaKeyOptions;
var gl;
var buffer;
var visibleRect;
var format;
var keyColorLoc;
var similarityLoc;
var smoothnessLoc;
var spillLoc;
var videoFrameBufferInit = {
    timestamp: 0,
    codedWidth: 0,
    codedHeight: 0,
    format: 'RGBA',
};
var chromaKeyOptions = "\nuniform vec3 keyColor;\nuniform float similarity;\nuniform float smoothness;\nuniform float spill;\n";
var RGBtoUV = "\nvec2 RGBtoUV(vec3 rgb) {\n  return vec2(\n    rgb.r * -0.169 + rgb.g * -0.331 + rgb.b *  0.5    + 0.5,\n    rgb.r *  0.5   + rgb.g * -0.419 + rgb.b * -0.081  + 0.5\n  );\n}\n";
var processChromaKey = "\nvec4 ProcessChromaKey(vec2 texCoord, vec4 rgba) {\n    float chromaDist = distance(RGBtoUV(rgba.rgb), RGBtoUV(keyColor));\n    float baseMask = chromaDist - similarity;\n    float fullMask = pow(clamp(baseMask / smoothness, 0., 1.), 1.5);\n    rgba.a = fullMask;\n    float spillVal = pow(clamp(baseMask / spill, 0., 1.), 1.5);\n    float desat = clamp(rgba.r * 0.2126 + rgba.g * 0.7152 + rgba.b * 0.0722, 0., 1.);\n    rgba.rgb = mix(vec3(desat, desat, desat), rgba.rgb, spillVal);\n    return rgba;\n}\n";
var rgb_FragmentShader = "\nprecision highp float;\n\nuniform sampler2D tex_y;\nvarying vec2 v_texCoord;\n\n".concat(chromaKeyOptions, "\n\n").concat(RGBtoUV, "\n\n").concat(processChromaKey, "\n\nvoid main() {\n    vec4 video_pixels_rgba = texture2D(tex_y, v_texCoord);\n    gl_FragColor = ProcessChromaKey(v_texCoord, video_pixels_rgba);\n}\n");
var rgb_VertexShader = "\nattribute vec4 a_vertexPosition;\nattribute vec2 a_texturePosition;\nvarying vec2 v_texCoord;\nvoid main(void)\n{\n  gl_Position = a_vertexPosition;\n  v_texCoord = a_texturePosition;\n}\n";
var i420_to_rgb_FragmentShader = "\nprecision highp float;\n\nuniform sampler2D u_image_frame;\nuniform vec2 u_resolution;\nvarying vec2 v_texCoord;\n\n".concat(chromaKeyOptions, "\n\n").concat(RGBtoUV, "\n\n").concat(processChromaKey, "\n\nvoid main() {\n  float x_offset = mod( gl_FragCoord.y ,2.0  ) < 1.0 ? 0.5 : 0.0 ;\n  vec4 y4 =  texture2D(u_image_frame, vec2 ( v_texCoord.x / 1.0  , v_texCoord.y / 1.5  )   )  ;\n  vec4 u4 = (texture2D(u_image_frame, vec2 ( x_offset + v_texCoord.x  / 2.0  ,2.0/3.0 +  v_texCoord.y / 6.0  )   ) -0.50 ) * 2.0 ;\n  vec4 v4 = (texture2D(u_image_frame, vec2 ( x_offset + v_texCoord.x / 2.0  , 5.0/6.0 + v_texCoord.y / 6.0  )   ) -0.50 ) * 2.0 ;   \n  \n  float y = y4[0] ;\n  float u = u4[0] ;\n  float v = v4[0] ;   \n\n  float R = clamp(y + 1.13 * v, 0.0, 1.0) ;\n  float G = clamp(y - 0.39 * u - 0.58 * v, 0.0, 1.0) ;\n  float B = clamp(y + 2.03 * u, 0.0, 1.0) ;\n\n  vec4 video_pixels_rgba = vec4( vec3(R,G,B), 1.0) ;\n\n  gl_FragColor = ProcessChromaKey(vec2 ( v_texCoord.x / 1.0  , v_texCoord.y / 1.5  ), video_pixels_rgba);\n}\n");
var i420_to_rgb_VertexShader = "\nattribute vec2 a_position;\nattribute vec2 a_texCoord;\nuniform vec2 u_resolution; \nvarying vec2 v_texCoord;\n  \nvoid main() {  \n  gl_Position =  vec4(( (a_position / u_resolution * 2.0) - 1.0)  * vec2(1, -1), 0, 1);  \n  v_texCoord = a_texCoord;  \n}\n";
var n12_to_rgb_FragmentShader = "\nprecision highp float;\nvarying vec2 v_texCoord;\nuniform sampler2D tex_y;\nuniform sampler2D tex_uv;\n\n".concat(chromaKeyOptions, "\n\n").concat(RGBtoUV, "\n\n").concat(processChromaKey, "\n\nvoid main() \n{\n    vec3 yuv, rgb;\n    vec3 yuv2r = vec3(1.164, 0.0, 1.596);\n    vec3 yuv2g = vec3(1.164, -0.391, -0.813);\n    vec3 yuv2b = vec3(1.164, 2.018, 0.0);\n\n    yuv.x = texture2D(tex_y, v_texCoord).r - 0.0625;\n    yuv.y = texture2D(tex_uv, v_texCoord).r - 0.5;\n    yuv.z = texture2D(tex_uv, v_texCoord).a - 0.5;\n\n    rgb.x = dot(yuv, yuv2r);\n    rgb.y = dot(yuv, yuv2g);\n    rgb.z = dot(yuv, yuv2b);\n\n    vec4 video_pixels_rgba  = vec4(rgb, 1.0);\n\n    gl_FragColor = ProcessChromaKey(v_texCoord, video_pixels_rgba);\n}\n");
var n12_to_rgb_VertexShader = "\nattribute vec4 a_vertexPosition;\nattribute vec2 a_texturePosition;\nvarying vec2 v_texCoord;\nvoid main(void)\n{\n  gl_Position = a_vertexPosition;\n  v_texCoord = a_texturePosition;\n}\n";
function getGl(width, height) {
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    exports.offscreenCanvas = new OffscreenCanvas(width, height);
    gl = exports.offscreenCanvas.getContext('webgl', { premultipliedAlpha: false });
    if (gl) {
        return true;
    }
    return false;
}
function getCanvasGL(canvas) {
    gl = canvas.getContext('webgl', { premultipliedAlpha: false });
    if (gl) {
        return true;
    }
    return false;
}
function createShader(type, src) {
    var shader = gl.createShader(type);
    gl.shaderSource(shader, src);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(shader));
    }
    return shader;
}
function createProgram(vertexShader, fragmentShader) {
    var program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    gl.useProgram(program);
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error(gl.getShaderInfoLog(program));
    }
    return program;
}
function createTexture(filter) {
    if (filter === void 0) { filter = gl.LINEAR; }
    var t = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, t);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filter);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filter);
    return t;
}
function initWebGL_rgb(width, height) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        return tslib_1.__generator(this, function (_a) {
            if (!getGl(width, height))
                return [2 /*return*/];
            initWebGL_rgb_with_gl();
            return [2 /*return*/];
        });
    });
}
exports.initWebGL_rgb = initWebGL_rgb;
function initWebGL_rgb_with_canvas(canvas) {
    if (!getCanvasGL(canvas))
        return;
    initWebGL_rgb_with_gl();
}
exports.initWebGL_rgb_with_canvas = initWebGL_rgb_with_canvas;
function initWebGL_rgb_with_gl() {
    gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
    var vs = createShader(gl.VERTEX_SHADER, rgb_VertexShader);
    var fs = createShader(gl.FRAGMENT_SHADER, rgb_FragmentShader);
    var program = createProgram(vs, fs);
    initVertexBuffers(program);
    gl.activeTexture(gl.TEXTURE0);
    gl.y = createTexture();
    gl.uniform1i(gl.getUniformLocation(program, 'tex_y'), 0);
    keyColorLoc = gl.getUniformLocation(program, 'keyColor');
    similarityLoc = gl.getUniformLocation(program, 'similarity');
    smoothnessLoc = gl.getUniformLocation(program, 'smoothness');
    spillLoc = gl.getUniformLocation(program, 'spill');
}
function initWebGL_I420(width, height) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var vs, fs, program, positionLocation, texcoordLocation, positionBuffer, x1, x2, y1, y2, texcoordBuffer, textures, texture, pixelData, u_image_frame, size, type, normalize, stride, offset, size, type, normalize, stride, offset, resolutionLocation;
        return tslib_1.__generator(this, function (_a) {
            if (!getGl(width, height))
                return [2 /*return*/];
            vs = createShader(gl.VERTEX_SHADER, i420_to_rgb_VertexShader);
            fs = createShader(gl.FRAGMENT_SHADER, i420_to_rgb_FragmentShader);
            program = createProgram(vs, fs);
            positionLocation = gl.getAttribLocation(program, 'a_position');
            texcoordLocation = gl.getAttribLocation(program, 'a_texCoord');
            positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            x1 = 0;
            x2 = 0 + width;
            y1 = 0;
            y2 = 0 + height;
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([x1, y1, x2, y1, x1, y2, x1, y2, x2, y1, x2, y2]), gl.STATIC_DRAW);
            texcoordBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0,
            ]), gl.STATIC_DRAW);
            textures = [];
            // create texture for the video frame
            {
                texture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, texture);
                // Set the parameters so we can render any size image.
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                pixelData = new Uint8Array(1.5 * width * height);
                // Upload the image into the texture.
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.LUMINANCE, width, height * 1.5, 0, gl.LUMINANCE, gl.UNSIGNED_BYTE, pixelData);
                textures[0] = texture;
            }
            u_image_frame = gl.getUniformLocation(program, 'u_image_frame');
            // set which texture units to render with.
            gl.uniform1i(u_image_frame, 0); // texture unit 1
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, textures[0]);
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
            gl.clearColor(0, 0, 0, 0);
            gl.clear(gl.COLOR_BUFFER_BIT);
            // Turn on the position attribute
            gl.enableVertexAttribArray(positionLocation);
            // Bind the position buffer.
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            // Tell the position attribute how to get data out of positionBuffer (ARRAY_BUFFER)
            {
                size = 2;
                type = gl.FLOAT;
                normalize = false;
                stride = 0;
                offset = 0;
                gl.vertexAttribPointer(positionLocation, size, type, normalize, stride, offset);
            }
            // Turn on the texcoord attribute
            gl.enableVertexAttribArray(texcoordLocation);
            // bind the texcoord buffer.
            gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);
            // Tell the texcoord attribute how to get data out of texcoordBuffer (ARRAY_BUFFER)
            {
                size = 2;
                type = gl.FLOAT;
                normalize = false;
                stride = 0;
                offset = 0;
                gl.vertexAttribPointer(texcoordLocation, size, type, normalize, stride, offset);
            }
            resolutionLocation = gl.getUniformLocation(program, 'u_resolution');
            // set the resolution
            gl.uniform2f(resolutionLocation, gl.canvas.width, gl.canvas.height);
            keyColorLoc = gl.getUniformLocation(program, 'keyColor');
            similarityLoc = gl.getUniformLocation(program, 'similarity');
            smoothnessLoc = gl.getUniformLocation(program, 'smoothness');
            spillLoc = gl.getUniformLocation(program, 'spill');
            // Draw the rectangle.
            gl.drawArrays(gl.TRIANGLES, 0, 6);
            return [2 /*return*/];
        });
    });
}
function initVertexBuffers(program) {
    var vertexBuffer = gl.createBuffer();
    var vertexRectangle = new Float32Array([
        1.0, 1.0, 0.0, -1.0, 1.0, 0.0, 1.0, -1.0, 0.0, -1.0, -1.0, 0.0,
    ]);
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, vertexRectangle, gl.STATIC_DRAW);
    var vertexPositionAttribute = gl.getAttribLocation(program, 'a_vertexPosition');
    gl.vertexAttribPointer(vertexPositionAttribute, 3, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(vertexPositionAttribute);
    var textureRectangle = new Float32Array([
        1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 1.0,
    ]);
    var textureBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, textureRectangle, gl.STATIC_DRAW);
    var textureCoord = gl.getAttribLocation(program, 'a_texturePosition');
    gl.vertexAttribPointer(textureCoord, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(textureCoord);
}
function initWebGL_NV12(width, height) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var vs, fs, program;
        return tslib_1.__generator(this, function (_a) {
            if (!getGl(width, height))
                return [2 /*return*/];
            gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
            vs = createShader(gl.VERTEX_SHADER, n12_to_rgb_VertexShader);
            fs = createShader(gl.FRAGMENT_SHADER, n12_to_rgb_FragmentShader);
            program = createProgram(vs, fs);
            initVertexBuffers(program);
            gl.activeTexture(gl.TEXTURE0);
            gl.y = createTexture();
            gl.uniform1i(gl.getUniformLocation(program, 'tex_y'), 0);
            gl.activeTexture(gl.TEXTURE1);
            gl.uv = createTexture();
            gl.uniform1i(gl.getUniformLocation(program, 'tex_uv'), 1);
            keyColorLoc = gl.getUniformLocation(program, 'keyColor');
            similarityLoc = gl.getUniformLocation(program, 'similarity');
            smoothnessLoc = gl.getUniformLocation(program, 'smoothness');
            spillLoc = gl.getUniformLocation(program, 'spill');
            return [2 /*return*/];
        });
    });
}
var ArrayBufferViewValue = Object.getPrototypeOf(Object.getPrototypeOf(new Uint8Array())).constructor;
function render_rgb(width, height, data) {
    gl.viewport(0, 0, width, height);
    gl.bindTexture(gl.TEXTURE_2D, gl.y);
    if (data instanceof ArrayBufferViewValue) {
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
    }
    else {
        // HTMLVideoElement
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, data);
    }
    gl.uniform3f(keyColorLoc, keyColor.r, keyColor.g, keyColor.b);
    gl.uniform1f(similarityLoc, similarity);
    gl.uniform1f(smoothnessLoc, smoothness);
    gl.uniform1f(spillLoc, spill);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    gl.flush();
    gl.finish();
}
exports.render_rgb = render_rgb;
function render_nv12(width, height, data) {
    var uvOffset = width * height;
    var view = new Uint8Array(data);
    gl.bindTexture(gl.TEXTURE_2D, gl.y);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.LUMINANCE, width, height, 0, gl.LUMINANCE, gl.UNSIGNED_BYTE, view.subarray(0, uvOffset));
    gl.bindTexture(gl.TEXTURE_2D, gl.uv);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.LUMINANCE_ALPHA, width / 2, height / 2, 0, gl.LUMINANCE_ALPHA, gl.UNSIGNED_BYTE, view.subarray(uvOffset));
    gl.uniform3f(keyColorLoc, keyColor.r, keyColor.g, keyColor.b);
    gl.uniform1f(similarityLoc, similarity);
    gl.uniform1f(smoothnessLoc, smoothness);
    gl.uniform1f(spillLoc, spill);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    gl.flush();
    gl.finish();
}
function render_i420(width, height, data) {
    var view = new Uint8Array(data);
    gl.activeTexture(gl.TEXTURE0);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.LUMINANCE, width, height * 1.5, 0, gl.LUMINANCE, gl.UNSIGNED_BYTE, view, 0);
    gl.uniform3f(keyColorLoc, keyColor.r, keyColor.g, keyColor.b);
    gl.uniform1f(similarityLoc, similarity);
    gl.uniform1f(smoothnessLoc, smoothness);
    gl.uniform1f(spillLoc, spill);
    gl.drawArrays(gl.TRIANGLES, 0, 6);
    gl.flush();
    gl.finish();
}
function transform(frame, controller) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var height, roundedFrameHeight, rect, error_1, newFrame;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    // When called from RTCRtpScriptTransforms the frame is an RtcEncodedVideoFrame, which is before decoding.
                    // It looks like we should be able to use WebCodecs API to decode the RtcEncodedVideoFrame, but that isnt available
                    // on Safari yet...
                    if (!gl ||
                        format !== frame.format ||
                        exports.offscreenCanvas.width !== frame.codedWidth ||
                        exports.offscreenCanvas.height !== frame.codedHeight) {
                        if (frame.format === 'NV12') {
                            initWebGL_NV12(frame.codedWidth, frame.codedHeight);
                        }
                        else if (frame.format === 'I420') {
                            initWebGL_I420(frame.codedWidth, frame.codedHeight);
                        }
                        format = frame.format;
                        height = 0;
                        if (frame.visibleRect)
                            height = frame.visibleRect.height;
                        roundedFrameHeight = height - (height % 2);
                        if (roundedFrameHeight !== height && frame.visibleRect) {
                            rect = {
                                x: frame.visibleRect.x,
                                y: frame.visibleRect.y,
                                width: frame.visibleRect.width,
                                height: roundedFrameHeight,
                            };
                            visibleRect = rect;
                            buffer = new ArrayBuffer(frame.allocationSize({ rect: rect }));
                        }
                        else {
                            visibleRect = frame.visibleRect;
                            buffer = new ArrayBuffer(frame.allocationSize({ rect: visibleRect }));
                        }
                        videoFrameBufferInit.codedWidth = frame.codedWidth;
                        videoFrameBufferInit.codedHeight = frame.codedHeight;
                    }
                    if (!visibleRect) return [3 /*break*/, 5];
                    _a.label = 1;
                case 1:
                    _a.trys.push([1, 3, , 4]);
                    return [4 /*yield*/, frame.copyTo(buffer, { rect: visibleRect })];
                case 2:
                    _a.sent();
                    return [3 /*break*/, 4];
                case 3:
                    error_1 = _a.sent();
                    return [2 /*return*/];
                case 4:
                    if (frame.format === 'NV12') {
                        render_nv12(visibleRect.width, visibleRect.height, buffer);
                    }
                    else if (frame.format === 'I420') {
                        render_i420(visibleRect.width, visibleRect.height, buffer);
                    }
                    _a.label = 5;
                case 5:
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    videoFrameBufferInit.timestamp = frame.timestamp;
                    newFrame = new VideoFrame(gl.canvas, videoFrameBufferInit);
                    frame.close();
                    controller.enqueue(newFrame);
                    return [2 /*return*/];
            }
        });
    });
}
function handleTransform(readable, writable) {
    readable.pipeThrough(new TransformStream({ transform: transform })).pipeTo(writable);
}
function isUnderJest() {
    return (typeof process !== 'undefined' &&
        typeof process.env !== 'undefined' &&
        typeof process.env.JEST_WORKER_ID !== 'undefined');
}
if (!isUnderJest() && typeof onmessage !== 'undefined') {
    onmessage = function (event) { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
        return tslib_1.__generator(this, function (_a) {
            if (!event.data)
                return [2 /*return*/];
            if (event.data.readable && event.data.writable) {
                return [2 /*return*/, handleTransform(event.data.readable, event.data.writable)];
            }
            else if (event.data.chromaKeyOptions) {
                updateChromaKeyOptions(event.data.chromaKeyOptions);
            }
            return [2 /*return*/];
        });
    }); };
}
// Handler for RTCRtpScriptTransforms.
if (typeof self !== 'undefined' && self.RTCTransformEvent) {
    self.onrtctransform = function (event) {
        var transformer = event.transformer;
        handleTransform(transformer.readable, transformer.writable);
    };
}
//# sourceMappingURL=chroma-key.worker.js.map